<!--
SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
SPDX-License-Identifier: CC-BY-SA-4.0
-->

# Prompt for Developer Agent: Phase 1, Step 1.2

You are a Senior Rust Developer. Your task is to wire up the new `RubyFrame` into the main draw loop in `lib.rs`. This implements **Phase 1, Step 1.2** of the [Frame Migration Plan](../../../doc/contributors/frame_migration.md).

## Context

The previous agent has implemented `ext/ratatui_ruby/src/frame.rs` containing the `RubyFrame` struct. Your job is to modify `lib.rs` to expose this frame to Ruby users when they pass a block to `RatatuiRuby.draw`.

## Task Specs

Modify `ext/ratatui_ruby/src/lib.rs`.

### 1. Register Module
- Add `mod frame;` to the module declarations.
- Ensure `init()` registers the `RatatuiRuby::Frame` class if `frame.rs` didn't do it automatically (it likely needs `frame::init` or similar if it uses `#[magnus::init]`). Actually, `RubyFrame` usually provides a way to register itself. If `frame.rs` doesn't have an init function, you may need to define the class in `lib.rs` init or call a helper.
    - *Assumption*: The `frame.rs` likely has a struct defined but maybe not a full `#[magnus::init]`. If it does, make sure to call it if needed. However, since we are using `#[magnus::wrap]`, we mostly just need to ensure the class is defined under `RatatuiRuby`.
    - **Check**: You might need to add `m.define_class("Frame", class::object())?` or similar if `frame.rs` didn't do it.

### 2. Update `draw` Signature
- **Current**: `fn draw(tree: Value) -> Result<(), Error>`
- **New**: `fn draw(args: &[Value]) -> Result<(), Error>`
- **Arity Update**: Change `m.define_module_function("draw", function!(draw, 1))` to `function!(draw, -1)` (variable arguments).

### 3. Implement `draw` Logic
- **Goal**: Support both `draw(tree)` (Legacy) and `draw { |frame| ... }` (New).
- **Logic Flow**:
    1. **Argument Parsing**:
        - Use `magnus::scan_args` to parse optional arguments.
        - Expect `(tree: Option<Value>)`.
        - Check for block: use `magnus::Ruby::get().unwrap().block_given()`.
    2. **Lock Terminal**: Same as before.
    3. **Draw Loop**:
        - Call `term.draw(|f| { ... })`.
    4. **Inside Closure**:
        - **If Block Given**:
            - Instantiate `RubyFrame` wrapping `f`.
            - `RubyFrame` creation might require unsafe casting or `RefCell` tricks depending on how Step 1.1 implemented it. Follow the pattern established in `frame.rs`.
            - Yield to block: `block.call((ruby_frame,))?`.
                - Note: To yield to the implicit block from Rust, you might need to capture it using `magnus::block::Block` in arguments or use `yield_value`.
                - *Better Approach*: Change `draw` signature to `fn draw(args: &[Value], block: Option<magnus::block::Proc>)`. This captures the block explicitly.
        - **If Tree Given (and no block)**:
            - Call `rendering::render_node(f, f.area(), tree)`.
        - **If Neither**:
            - Return error: "Must provide either a tree or a block".

## Implementation Details

- **File**: `ext/ratatui_ruby/src/lib.rs`
- **Imports**: Add `frame::RubyFrame` (or whatever it was named).
- **Safety**: Ensuring the `RubyFrame` (which wraps a short-lived `f`) doesn't escape the block is crucial. Typically `RubyFrame` shouldn't be returnable.

## Definition of Done for this Step
- `RatatuiRuby.draw` can be called with a block (Rust compiles).
- `RatatuiRuby.draw` can still be called with a tree (Legacy support).
- `RubyFrame` is passed to the block.
