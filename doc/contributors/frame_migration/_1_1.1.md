<!--
SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
SPDX-License-Identifier: CC-BY-SA-4.0
-->

# Prompt for Developer Agent: Phase 1, Step 1.1

You are a Senior Rust Developer. Your task is to implement the initial `RubyFrame` struct for the RatatuiRuby gem. This works towards **Phase 1, Step 1.1** of the [Frame Migration Plan](../../../doc/contributors/frame_migration.md).

## Context

We are migrating from a tree-based rendering model to a frame-based immediate mode rendering model, mirroring the native Rust `ratatui` crate. The goal is to expose a `Frame` object to Ruby that allows explicit widget placement (e.g. `frame.render_widget(widget, rect)`).

## Task Specs

Create a new file `ext/ratatui_ruby/src/frame.rs` and implement the `RubyFrame` struct.

### 1. `RubyFrame` Struct
- **Wrap `ratatui::Frame`**: The struct should hold a reference to the native frame.
    - *Note*: `ratatui::Frame` has a lifetime. Since generic lifetimes in Magnus structs can be tricky, you may need to use `RefCell` or unsafe pointer casting to store the frame reference for the duration of the draw block. Ensure you document safety invariants if you use `unsafe`. A recommended pattern is `struct RubyFrame { inner: RefCell<Frame<'static>> }` (casting lifetime) but valid only during the callback.
- **Magnus integration**: Use `#[magnus::wrap(class = "RatatuiRuby::Frame")]` to expose it to Ruby.

### 2. Method: `area`
- **Signature**: `def area -> Rect` (Ruby)
- **Rust Implementation**:
    - Borrow the inner frame.
    - Call `frame.area()` to get the native `Rect`.
    - Convert it to a Ruby `RatatuiRuby::Rect` instance.
    - **Implementation Hint**: You can instantiate a Ruby `Rect` using `magnus`:
      ```rust
      let module = ruby.define_module("RatatuiRuby")?;
      let class = module.const_get::<_, magnus::RClass>("Rect")?;
      class.funcall("new", (area.x, area.y, area.width, area.height))
      ```
      (See `ext/ratatui_ruby/src/rendering.rs` for similar logic).

### 3. Method: `render_widget`
- **Signature**: `def render_widget(widget, area) -> nil` (Ruby)
- **Rust Implementation**:
    - Arguments: `widget: Value`, `area: Value`.
    - **Action**: Delegate to `crate::rendering::render_node`.
        - `render_node` already handles parsing Ruby widgets and dispatching to Rust renderers.
    - **Helper**: You might need to cast the incoming `area` `Value` to a native `ratatui::layout::Rect` if `render_node` expects a specific type, or pass it through if `render_node` handles it.
    - *Check `src/rendering.rs`*: `pub fn render_node(frame: &mut Frame, area: Rect, node: Value)`.
        - You will need to parse the ruby `area` argument into a Rust `Rect` before calling `render_node`.

## File to Create
- `ext/ratatui_ruby/src/frame.rs`

## References
- `ext/ratatui_ruby/src/rendering.rs`: Use `render_node` to avoid duplicating widget parsing logic.
- `doc/contributors/frame_proposal.md`: See "Implementation" section for `RubyFrame` reference.
- `sig/ratatui_ruby/schema/rect.rbs`: Reference for the Ruby `Rect` class.

**Do not update `lib.rs` yet.** That is Step 1.2. Just create and implement `frame.rs`.
